## Memoization

when using recursion, you might be computing the result for previously computed inputs.
EX) fib(5) = fib(4) + fib(3)
fib(4) = fib(3) - fib(2) fib(3) = fib(2) + fib(1)
..... --> Here we can see that we call fib(2) twice

- if the value of fib(2) is memoized, we can use it again without any further computation.

```python
class Fiber():
    def __init__(self):
        self.memo = {}
    def fib(self,n):
        if n <= 1:
            return n
        elif n in self.memo:
            print(f"grabbing memo {n}")
            return self.memo[n]
        result = self.fib(n-1) + self.fib(n-2)
        print(f"computed fib({n})",self.memo,result)
        return result
```

results

```python
    a = Fiber()
    a.fib(5)
```

computed fib(2) {2: 1} 1
computed fib(3) {2: 1, 3: 2} 2
grabbing memo 2
computed fib(4) {2: 1, 3: 2, 4: 3} 3
grabbing memo 3
computed fib(5) {2: 1, 3: 2, 4: 3, 5: 5} 5
