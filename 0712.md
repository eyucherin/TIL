## RECURSION --> Memoization

when using recursion, you might be computing the result for previously computed inputs.
EX) fib(5) = fib(4) + fib(3)
fib(4) = fib(3) - fib(2) fib(3) = fib(2) + fib(1)
..... --> Here we can see that we call fib(2) twice

- if the value of fib(2) is memoized, we can use it again without any further computation.

```python
class Fiber():
    def __init__(self):
        self.memo = {}
    def fib(self,n):
        if n <= 1:
            return n
        elif n in self.memo:
            print(f"grabbing memo {n}")
            return self.memo[n]
        result = self.fib(n-1) + self.fib(n-2)
        print(f"computed fib({n})",self.memo,result)
        return result
```

results

```python
    a = Fiber()
    a.fib(5)
```

computed fib(2) {2: 1} 1
computed fib(3) {2: 1, 3: 2} 2
grabbing memo 2
computed fib(4) {2: 1, 3: 2, 4: 3} 3
grabbing memo 3
computed fib(5) {2: 1, 3: 2, 4: 3, 5: 5} 5

# MATRIX

m = (
[['Mon',18,20,22,17],
    ['Tue',11,18,21,18],
    ['Wed',15,21,20,19],
    ['Thu',11,20,22,21],
    ['Fri',18,17,23,22],
    ['Sat',12,22,20,18],
   ['Sun',13,15,19,16]])

### copying

```python
    copied_matrix = [row[:] for row in m]
    m.append(["holiday",192,212,31,2123])
    print(copied_matrix) # hard copy --> does not include ["holiday",192,212,31,2123]
    print(m)
```

### transposing(setting col to rows and rows to cols)

```python
    transposed_matrix = zip(*m)
    print(list(transposed_matrix))
```

### sorting

- the sorting algorithm for python is called Tim Sort time complexity is O(NlogN)
