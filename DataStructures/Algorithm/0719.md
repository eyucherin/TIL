# heap and heapq

- Python's heapq module is a module used to create a min heap.
- parent(k) --> children (2k + 1) and (2k + 2)
- aka priority queue
- Smallest value will always be heap[0]

### heappush and heappop

```python
import heapq
heap = []
values = [4,1,7,3]

for val in values:
    heapq.heappush(heap,i)
# heap = [1,3,7,4]
heapq.heappop(heap) # pops smallest value
# return 1  and heap = [3,7,4]
```

### heapify

```python
heap = [4, 1, 7, 3, 8, 5]
heapq.heapify(heap)
print(heap)
# [1, 3, 5, 4, 8, 7]
```

## Creating a MaxHeap with heapq

```python
import heapq
def maxHeap(nums):
    heap = []
    res = []
    for num in nums:
        heapq.heappush(heap,(-num,num))
    while heap:
        res.append(heapq.heappop(heap)[1])
    return res
```

example

```python
nums = [4,1,7,3,8,5]
heap = [(-8, 8), (-7, 7), (-5, 5), (-1, 1), (-3, 3), (-4, 4)]
nums = [8, 7, 5, 4, 3, 1]
```

### kth_smallest

```python
import heapq
def kth_smallest(nums,k):
    heap = []
    for i in nums:
        heapq.heappush(nums,i)
    val = None
    for _ in range(k):
        val = heapq.heappop(heap)
    return val
```

### kth_biggest

```python
import heapq
def kth_biggest(nums,k):
    heap = []
    for i in nums:
        heapq.heappush(heap,(-i,i))
    val = None
    for _ in range(k):
        val = heapq.heappop(heap)[1]
    return val
```

### heap sort

```python
import heapq
def heap_sort(nums):
    heapq.heapify(nums)
    sorted_vals = []
    while nums:
        sorted_vals.append(heapq.heappop(nums))
    return sorted_vals

heap_sort([4, 1, 7, 3, 8, 5])
```

# Trie

Tree like data structure where the nodes of a tree store the entire alphabet, and strings and words can be retrieved by traversing down a path of a tree

```python
class Trie:
    def __init__(self):
        self.trie = {}

    def insert(self,word):
        t = self.trie
        for i in word:
            if i not in t:
                t[i] = {}
            t = t[i]
        t["-"] = True

    def search(self,word):
        t = self.trie
        for i in word:
            if i not in t:
                return False
            t = t[i]
        return "-" in t

    def startsWith(self,prefix):
        t = self.trie
        for i in prefix:
            if i not in t:
                return False
            t = t[i]
        return True

A = Trie()
A.insert("Apples")
A.insert("Aunt")
print(A.search("Apples"))
print(A.startsWith("App"))
print(A.trie)

#True
#True
#{'A': {'p': {'p': {'l': {'e': {'s': {'-': True}}}}}, 'u': {'n': {'t': {'-': True}}}}}


```
