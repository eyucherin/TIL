# Dynamic Programming

- algorithm technique for solving optimization problems by breaking it into smaller pieces
- optimal solution to the bigger problem depends on the optimal solution to its subProblems

### Characteristics of Dynamic Programming

1. OVERLAPPING SUB PROBLEMS
2. OPTIMAL SUBSTRUCTURE PROPERTY

# DP Methods( Memoization and Tabulation)

### TOP BOTTOM (Memoization)

- calculate n first and then move down
- we try to solve the bigger problem by recursively finding the solution to smaller sub-problems.
- Whenever we solve a sub-problem, we cache its result so that we don’t end up solving it repeatedly if it’s called multiple times

Fibonacci Example

```python
fib_cache = {0 : 0, 1 : 1}

def fib(n):
    if n in fib_cache:
        return fib_cache[n]
    fib_cache[n] = result = fib(n-1) + fib(n-2)
    return result
```

```python
def bFib(n):
    memo = {}
    def sFib(n):
        if n in memo:
            return memo[n]
        memo[n] = fib(n-1) + fib(n-2)
    return(fib(n))
```

### BOTTOM TOP (Tabulation)

- calculate smaller numbers first and then move up
- avoiding Recursion
- typically done by filling up an n dimensional table

```python
def calculateFibonacci(n):
  dp = [1, 1]
  for i in range(2, n ):
    dp.append(dp[i - 1] + dp[i - 2])
  return dp[-1]


def main():
  print("5th Fibonacci is ---> " + str(calculateFibonacci(5)))
  print("6th Fibonacci is ---> " + str(calculateFibonacci(6)))
  print("7th Fibonacci is ---> " + str(calculateFibonacci(7)))


main()
```
