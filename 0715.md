# Stack

|     |     |     | push/pop |
| --- | --- | --- | -------- |
| 1   | 2   | 3   | 4        |

# Queue

Enqueue/Dequeue/Front/Back/isEmpty
| dequeue | | | enqueue |
| ------- | --- | --- | ------- |
| 1 | 2 | 3 | 4 |

## Implementing a Queue using two stacks

#### Approach 1 (using one stack)

```python
class myQueue:
    def __init__(self):
        self.stack = []

    def enqueue(self,x):
        self.stack.append(x)

    def dequeue(self):
        self.stack = self.stack[::-1]
        val = self.stack.pop()
        self.stack = self.stack[::-1]
        return val

    def top(self):
        return self.stack[0]

    def empty(self):
        return self.stack == []
```

#### Approach 2 (using two stacks)

```python
class myQueue:
    def __init__(self):
        self.input = [] # main stack
        self.output = []

    def enqueue(self,x):
        self.input.append(x)

    #input = [1,2,3,4] put all values into output from the back to from output = [4,3,2,1], pop the last val and save it, and the put all those values from the back to front back to input = [2,3,4] return 1
    def dequeue(self):
        while self.input:
            self.output.append(self.input.pop())
        val = self.output.pop()
        while self.output:
            self.input.append(self.output.pop())
        return val

    def top(self):
        return self.input[0]

    def empty(self):
        return self.input == []
```

## Implementing a Stack using a Queue

Push/Pop/Top/isEmpty/Search

#### Approach 1

```python
from collections import deque
class myStack:
    def __init__(self):
        self.q = deque()

    def push(self,val):
        self.q.append(val)

    def pop(self):
        for i in range(len(self.q) - 1):
            self.q.append(self.q.popleft())
        return self.q.popleft()

    def isEmpty(self):
        return len(self.q) == 0

    def top(self,val):
        return self.q[-1]
```

pop visualization

original
| 1 | 2 | 3 | 4 |
| --- | --- | --- | --- |

move 1
| 2 | 3 | 4 | 1 |
| --- | --- | --- | --- |

move 2
| 3 | 4 | 1 | 2 |
| --- | --- | --- | --- |

move3
| 4 | 1 | 2 | 3 |
| --- | --- | --- | --- |

popleft(4)
| 4 | 1 | 2 | 3 |
| --- | --- | --- | --- |

return it --> 4

final list
| 1 | 2 | 3 |
| --- | --- | --- |

# Binary Search

iterative

```python
def binSearch(arr,x):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if mid < x:
            left = mid + 1
        elif mid > x:
            right = mid - 1
        else:
            return (mid)
    return -1


```

recursive approach

```python
def binSearch(arr,left,right,x):
    while left<=right:
        mid = (right + left ) //2
        if arr[mid] > x:
            return binSearch(arr,left,mid-1,x)
        elif arr[mid] < x:
            return binSearch(arr,mid + 1, right,x)
        return mid
    return -1
binSearch([2,3,4,10,40],0,4,10)

```
